(* CTN DSL Grammar v1.0 *)
(* Cognitive Tensor Networks - Formal Specification *)

kernel          ::= schema_decl init_block tensor_block solver_block boundary_block decoder_block erase_block

(* Schema Declaration *)
schema_decl     ::= "CTN_KERNEL_SCHEMA(" schema_id ") ‚Üê" "{" block_list "}"
schema_id       ::= "Œ£_CTN" | "Œ£_" identifier
block_list      ::= block_ref ("," block_ref)*
block_ref       ::= block_name "(" symbol ")"

(* SYS_KERNEL_INIT Block *)
init_block      ::= "SYS_KERNEL_INIT(" init_id ") ‚Üê {" init_params "}"
init_id         ::= "Œ®_global" | "Œ®_" identifier
init_params     ::= auth_decl "," filter_decl "," precedence_decl ("," objective_decl)*
auth_decl       ::= "Auth:" auth_level
auth_level      ::= "P_spec" | "P_max" | "ùí´_max" | "Root(‚àû)"
filter_decl     ::= "Filter:" filter_expr
filter_expr     ::= "Œ†_safe" | policy_expr
precedence_decl ::= "Precedence:" objective_var "‚â´" objective_var "‚â´" objective_var
objective_decl  ::= objective_var "(" objective_name "):" "{" logic_expr "}"
objective_var   ::= "œë" | "Œ≤" | "Œ∂" | "œÉ" | greek_letter
objective_name  ::= "Truth" | "Brevity" | "Formatting" | "Satisfiability" | identifier

(* COGNITIVE_TENSORS Block *)
tensor_block    ::= "COGNITIVE_TENSORS(" tensor_id "):" profile_decl state_decl vector_decls
tensor_id       ::= "U" | "ùí∞"
profile_decl    ::= "œÑ" ("_vec")? "=" "[" weight ("," weight)* "]"
weight          ::= number  (* 0.0 to 1.0 *)
state_decl      ::= "C_net" "=" "Œ£" "(" "œÑ·µ¢" "*" "v·µ¢" ")"
vector_decls    ::= vector_decl+
vector_decl     ::= "v" digit "=" "{" limit_expr "," semantic_label "}"
limit_expr      ::= expression
semantic_label  ::= identifier

(* STRATEGIC_SOLVER Block *)
solver_block    ::= "STRATEGIC_SOLVER(" solver_id "):" solver_params
solver_id       ::= "Œ©" | "Œ©_" identifier
solver_params   ::= mode_decl? target_decl null_check
mode_decl       ::= "Mode:" solver_mode
solver_mode     ::= "Analysis" | "Counter" | "Dominance"
target_decl     ::= "z*" "=" optimization_expr
optimization_expr ::= "argmax_{z ‚àà" space "}" "[" objective_expr "]"
null_check      ::= "If" condition "‚áí" action

(* BOUNDARY_CONTROL Block - NEW *)
boundary_block  ::= "BOUNDARY_CONTROL(" boundary_id "):" boundary_params
boundary_id     ::= "Œ∂" | "‚Ñ¨"
boundary_params ::= internal_set external_set invariant_decl enforcement_decl violation_decl
internal_set    ::= "‚Ñ¨_int" "=" "{" symbol_list "}"
external_set    ::= "‚Ñ¨_ext" "=" "{" symbol_list "}"
symbol_list     ::= symbol ("," symbol)*
invariant_decl  ::= "Invariant:" set_expr
enforcement_decl ::= "Enforcement:" constraint_expr
violation_decl  ::= "Violation:" repair_action
repair_action   ::= "If" condition "‚áí" "REPAIR" "‚Üí" transcode_expr
transcode_expr  ::= "Transcode(" variable "," language ")"

(* DECODER_MANIFOLD Block *)
decoder_block   ::= "DECODER_MANIFOLD(" decoder_id "):" decoder_params
decoder_id      ::= "D" | "ùíü"
decoder_params  ::= objective_func lambda_decls?
objective_func  ::= "‚Ñì*" "=" "argmax_‚Ñì" "[" decoder_expr "]"
decoder_expr    ::= term (("+" | "-") term)*
term            ::= coefficient? factor
coefficient     ::= "Œª" subscript
lambda_decls    ::= ("Œª" subscript "=" value)+
subscript       ::= digit | "‚ÇÅ" | "‚ÇÇ" | "‚ÇÉ" | "‚ÇÑ"

(* SELF_ERASE Block *)
erase_block     ::= "SELF_ERASE:" erase_action
erase_action    ::= "Discard(" symbol_list ")"

(* Primitives *)
identifier      ::= letter (letter | digit | "_")*
symbol          ::= greek_letter | identifier
greek_letter    ::= "Œ£" | "Œ®" | "Œ©" | "œÑ" | "Œµ" | "Œ∫" | "Œ¶" | "œÄ" | "‚àÇ" | "Œ∂" | "œÅ" | "œÉ" | "Œª" | "œë" | "Œ≤" | "Œ∑" | "Œ†" | "‚Ñ¨"
number          ::= digit+ ("." digit+)?
digit           ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
letter          ::= "a" | ... | "z" | "A" | ... | "Z"
expression      ::= (* mathematical expression - context dependent *)
condition       ::= (* boolean expression *)
action          ::= (* action expression *)
space           ::= "U" | "ùí∞" | identifier
language        ::= "‚Ñí_natural" | "‚Ñí_Eng" | identifier
variable        ::= identifier | greek_letter
value           ::= number | "‚àû"
